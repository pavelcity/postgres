
CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    fio VARCHAR(100),
    pol CHAR(1),
    birthday DATE,
    oms BIGINT,
    card_num INT,
    area_num INT,

    FOREIGN KEY (area_num)
    REFERENCES med_area (area_num)
    ON DELETE CASCADE
);

CREATE TABLE med_area (
    area_num_id SERIAL PRIMARY KEY,
    area_num INT UNIQUE,
    area_address VARCHAR(1000)
);


---

CREATE TABLE patients (
patient_id SERIAL PRIMARY KEY, -- Главный ключ для JOIN
oms BIGINT NOT NULL UNIQUE -- Уникальный бизнес-ключ для ссылок
);

-- Теперь можно создавать таблицы, которые ссылаются на patient_id
CREATE TABLE some_table (
id SERIAL PRIMARY KEY,
patient_id INTEGER REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- И таблицы, которые логичнее ссылаются прямо на номер полиса (OMS)
CREATE TABLE talons (
talon_id SERIAL PRIMARY KEY,
oms_num BIGINT REFERENCES patients(oms) ON DELETE CASCADE -- Ссылка на oms!
);


----
update patients
set fio = 'Жулебина Светлана Ивановна'
where patient_id = 1


---

update patients
set fio = concat ('фио - ', fio)

----

CREATE TABLE
NOT NULL - значение в этой таблице никогда не может быть пустым
INSERT


CREATE TABLE users (
id BIGINT NOT NULL PRIMARY KEY,
first_name VARCHAR(64) NOT NULL,
lats_name VARCHAR(64) NOT NULL,
email VARCHAR(128) NOT NULL,
)


INSERT INTO users (id, first_name, lats_name, email)
VALUES (1, 'Windows', 'OS', 'win@win.com')


UPDATE users SET
email = 'some@mail.com'
WHERE id = 0



DELETE FROM users
WHERE id = 1 OR id = 3




CREATE TABLE spendings (
id BIGINT NOT NULL PRIMARY KEY,
price INT NOT NULL,
created_at TIMESTAMP DEFAULT now(),
user_id BIGINT NOT NULL,

CONSTRAINT user_id_fk FOREIGN KEY (user_id) REFERENCES users (id)
);



SELECT * FROM spendings
JOIN users ON users.id = spendings.user_id

SELECT spendings.* FROM spendings
JOIN users ON users.id = spendings.user_id

SELECT spendings.*, users.first_name FROM spendings
JOIN users ON users.id = spendings.user_id


loloLO77



——
В MySQL поддерживаются следующие правила целостности, которые накладывают ограничения на данные в пределах одной
таблицы:
1. Запрет неопределенных значений (not null)
2. Уникальность значения (unique)
3. Первичный ключ (Primary key)
Кроме того, для ограничения ссылочной целостности существуют внешние ключи (foreign key).




Запрет неопределенных значений (NOT NULL)
NULL - это специальное значение, которое используется в SQL для обозначения отсутствия какого-либо значения в ячейке
таблицы (NULL не равно 0).
NOT NULL - проверка на непустое значение.

Для чего нужен PRIMARY KEY?
Первичный ключ, это ограничение, которое позволяет нам однозначно идентифицировать строки в таблице. Объявив его, мы
знаем, что система не позволит нам задублировать информацию.


Добавление столбца
alter table patients add column card_num int;


Внешний ключ (FOREIGN KEY)

Удаление таблицы
drop table temp;